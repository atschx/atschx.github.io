---
layout: post
title:  Think in Push (1)(APNs篇)
author: Albert
date:   2015-11-30 13:18:35
categories: tech
---

> Apple Push Notification service (APNs for short) is the centerpiece of the remote notifications feature. It is a robust and highly efficient service for propagating information to iOS and OS X devices. Each device establishes an accredited and encrypted IP connection with the service and receives notifications over this persistent connection. If a notification for an app arrives when that app is not running, the device alerts the user that the app has data waiting for it.
> 
> [see more](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW9)

![apns-workflow](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/remote_notif_simple_2x.png)

# 工作流程简述：

1. **Provider** 将包含`离线通知的报文t`提交到 APNs服务器(服务器后台负责维护与APNs的通讯工作)
2. **APNs** 将接收到的`报文`推送到具体的apple设备(APNs服务器负责与用户Apple设备的通讯工作)
3. **Apple设备** 负责接收来自APNs的通知并将其关联至已安装的某个App

> 在以上几个个环节中：
> 
> * 服务提供商可以`控制`将通知推送给哪些用户(`受众`)，因此需要管理用户的标识性信息(即**DeviceToken**)
> 
> 
> * APNs服务器需要**准确**地向一个具体的Apple设备推送通知(上一步必须告知DeviceToken)
> 
> 
> * Apple设备接收到通知后可以精确地跳转至具体的App(第一步也必须告知其App的BundleId）

# 实现APNS的正确姿势：

1. 获取安装app的iphone设备Token信息
2. 按照APNs定义的协议与apple推送服务器通讯
3. 采用一些容错措施提高送达率

**服务承诺**：`best effort`.(这一点基本上对外声明，此服务只能用作在app未启动时有新的消息到达的提示性通知，但不可用作高实时性和一致性的场景)

## Step1:获取用户设备的deviceToken

> 只有用户在安装某个app后点击允许接受push通知时，app服务商(`provider`)才能获取到DeviceToken。

![Sharing the device token](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/registration_sequence_2x.png)

## Step2:Provider与APNs通讯

> As a provider you communicate with Apple Push Notification service over a binary interface. This interface is a high-speed, high-capacity interface for providers; it uses a streaming TCP socket design in conjunction with binary content. The binary interface is asynchronous.
> 
> * 正式环境 gateway.push.apple.com, port 2195
> 
> 
> * 开发环境 gateway.sandbox.push.apple.com, port 2195

此部分作为**APNs**方需鉴定**Provider**的合法性(_因此Provider需提供签名的push证书_)。通讯环节基于安全考虑启用TLS加密进行交换数据。

`If you send a notification that is accepted by APNs, nothing is returned.`（这句让无数国内开发者犯难，一个成功的提交不应该给一个回执吗？）其实想想也对，在IM系统中我们曾经遇到过类似场景：用户接收到消息并查看后需发送一个回执告知server此消息已读（Server端对用户已读消息的offset进行偏移）。对客户端而言你尽管向server提交回执信息，Server并不会对客户端做一个成功回执。原因：长连模式下的通讯本身server端需要处理大量的实时入口请求，对于`一致性要求并不高的协议`基本上没必要作出成功与否的回应，一方面提高server自身的处理能力，另一方面也可以减少网络出口带宽（仁者见仁，智者见智）。也许在`REST式API`横行的今天，开发者们俨然养成的**基于request_response**的思维定式受到了挑战。

------

Feedback信息的获取则由另一个服务对外提供：

* feedback.push.apple.com, port 2196
* feedback.sandbox.push.apple.com , port 2196



# 开发实现备注

如火如荼的开源社区，早已为`Provider`们封装好了一些第三方推送库（可谓是`前人栽树，后人乘凉`）。

如何选择的第三方库？(Don't repeat yourself!) [github上apns按star降序搜索结果](https://github.com/search?o=desc&q=apns&ref=searchresults&s=stars&type=Repositories&utf8=%E2%9C%93)

感谢各位前辈把私货毫无保留的奉献出来，作为创业中的开发者在`天下武功，唯快不破`的拿来主义文化下即便浮躁也要记得反哺社区。

本文将聚焦于服务器与APNs之间的高效通讯实现细节进行详细阐述。

### 第一步：管理用户的deviceToken

相对于整体实现而言，此环节最简单。用户在安装App后，点击允许接收来自xx的通知时，Provider即可获取到其对应的DeviceToken信息，对其进行持久化存储(传统数据库/nosql等)，管理代价并不高。

### 第二步：合理的维持与APNs的连接

连接的建立与维持策略

### 第三步：发送报文到server

数据格式：

![Notification format](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/aps_binary_provider_3_2x.png)

# Think more(different)

**Tips** 离线推送作为一个基础组件存在于基础服务集群中，谨记与产品业务解耦。

* 基础可量化的指标：吞吐量、错误率。


* 结合业务的量化指标：覆盖范围，转化率(需要提前设计转化率定义)

只需要将此部分信息与用户的其他信息进行关联即可，以实现后续的针对用户画像的某个维度下的用户进行消息推送，实现精准的推送而不是无休止的骚扰，最后导致用户不得不设置为不接受此App的push。（题外话：当你的App对用户提供精确并实用的通知性Push服务时，用户是没有理由关闭其Push服务的）倘若不经任何筛选的信息不断推送到用户设备端，在这个信息过载时代无疑是浪费用户的时间。